### Prioritized TODOs (AI slop)

- Vector search (must-have)
  - Implement KNN scan baseline (brute-force over `nodeVectors` with SIMD), support L2, cosine, dot-product, optional normalization.
  - Add approximate indexes per `tagId` (HNSW or IVF-PQ); persist index, background builder, incremental updates.
  - Keep `vecTagMeta` extended with metric, build params, quantization, versioning.
  - Ensure transactional consistency between LMDB updates and vector index (replay queue or rebuild-on-start with checkpoints).
  - Add constraints and validation on vector `dim` and data endianness; document canonical float32 layout.

- Graph queries and indexes
  - Extend `neighbors` to:
    - Filter on edge properties and edge types with predicates.
    - Optionally return edge IDs and/or edge props with neighbor IDs.
    - Deduplicate for non-Both directions when multiple parallel edges exist, or provide a flag to return multi-edges.
    - Deterministic ordering (by edge id, type, or custom), pagination/offset.
  - Add path queries (1..N hops), BFS/DFS, constrained path by labels/types/props.
  - Add secondary indexes:
    - Node property index: labelId + keyId + value → nodeId (support equality and range for numeric types).
    - Edge property index: typeId + keyId + value → edgeId.
  - Add API to fetch edge properties (you have `updateEdgeProps`, but no read API to get them with edges).
  - Edge constraints: optional uniqueness (src, typeId, dst), upsertEdge, and bulk edge ingestion.

- Data model and schema
  - Define and persist dictionaries for label names, property key names, and types (you only have `uint32_t` ids in value/props).
  - Property typing and coercion rules; enforce types on write.
  - Schema evolution: use `ensure_schema_version()` to run migrations; add explicit migrations with versioned steps.

- RPC/API layer
  - Map store exceptions to structured RPC errors; wrap each method to return clear error codes/messages rather than letting exceptions cross process boundaries.
  - Streaming or paged responses for large scans (neighbors, property queries, full vector scans).
  - Batch read endpoints symmetric to `writeBatch` (e.g., `getNodes`, `getEdges`, `getVectors` batch).
  - Server-side input validation: size caps for bytes/props, safe limits, guard against pathological inputs.

- Consistency, transactions, and concurrency
  - LMDB single-writer is fine, but clarify concurrency model; ensure one write txn at a time and snapshot reads.
  - Define isolation guarantees and document them (read-your-writes within a session?).
  - Crash-consistency for vector indexes: startup recovery (rebuild or WAL-backed repair).
  - Referential integrity: verify `src`/`dst` exist on `addEdge`, and enforce tag meta existence for vectors.

- Performance
  - Memory-layout: avoid redundant copies in hot paths (decode/encode); consider arena buffers for values and vectors.
  - Cursors: use `MDB_SET_RANGE` correctly and prefetch loops; consider batched LMDB reads.
  - Label filter in `neighbors` currently fetches node headers repeatedly; add a label-to-node index (you have one), and/or cache label sets.
  - Consider per-label posting lists intersected with property indexes for fast node lookups.

- Operations and reliability
  - Configurability:
    - CLI flags for map size (`--map-size`), sync (`MDB_NOSYNC`/`WRITEMAP` toggles), max DBs, readers.
    - Vector index parameters per tag (M, efConstruction, efSearch).
  - Map growth: handle `MDB_MAP_FULL` by allowing live resize via admin RPC or documented restart flow.
  - Backups and snapshotting: consistent online backup RPC or CLI; verify with tests.
  - Health endpoints and readiness checks; graceful shutdown (signal handling) to flush indexes and unlink unix socket safely.
  - Data integrity tools: verify/repair commands, reindex from LMDB.
  - Metrics and tracing: Prometheus counters (ops, bytes, latencies), KJ logs with structured fields, optional OpenTelemetry spans.

- Security
  - AuthN/AuthZ for RPC: tokens or mTLS; per-namespace permissions on labels/types/ops.
  - TLS for TCP mode; unix socket permissions for local mode.
  - Input size limits, rate limiting, and quotas.

- Developer experience and testing
  - Expand tests: property indexes, edge prop queries, neighbors semantics (Both vs dedup), cascading deletes, vector KNN correctness, recovery after crash.
  - Benchmarks: throughput (writes, scans), tail latency for KNN and neighbors; dataset generators.
  - Client SDKs and examples for multiple languages.
  - Docs: data model (hot vs cold props, labels, vectors), consistency, operational runbooks.

- Misc correctness fixes and niceties
  - Neighbors duplicate handling for non-Both modes (option or default dedup).
  - Remove `vecTagMeta` entries when last vector of a tag is deleted (or track refcounts).
  - Edge reads: add `getEdgeProps` and `getEdgesByNodeAndType` convenience.
  - Return shapes: consider returning node headers in neighbors results behind a flag to avoid N+1 round trips.
  - Consider compression for large vectors (optional Zstd or quantization) and for large bytes props.

### Small `main` and server polish
- `@main.cpp`
  - Add CLI for map size, LMDB flags, and logging level; signal handling for graceful shutdown.
  - Optionally drop and recreate unix socket atomically; set permissions.
- `@server.cpp`
  - Wrap all calls with try/catch; translate to RPC error status.
  - Add request validation and size limits.

### Minimal first milestones
- Implement exact KNN scan with cosine and L2; add `metric` in `vecTagMeta`.
- Add edge property read API and enhance `neighbors` filtering on edge props.
- Add basic node property equality index and query API.
- RPC error mapping and input validation.
- Metrics and map-size configurability.

- Implemented a gap analysis of `@server.cpp`, `@main.cpp`, and `@store.cpp` and produced a prioritized TODO list.
- Highlighted exact code areas for KNN, neighbor dedup, and RPC error handling with citations.Z